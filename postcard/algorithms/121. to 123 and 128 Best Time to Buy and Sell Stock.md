---
tags:
  - type/lit
  - topic/learning
  - status/archive
source: 《卡片盒笔记法》 by Sönke Ahrens
---
[121. Best Time to Buy and Sell Stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/)
[122. Best Time to Buy and Sell Stock II](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/)
[123. Best Time to Buy and Sell Stock III](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/)
[188. Best Time to Buy and Sell Stock IV](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/)
## Text
You are given an array `prices` where `prices[i]` is the price of a given stock on the `ith` day.

You want to maximize your profit by choosing a **single day** to buy one stock and choosing a **different day in the future** to sell that stock.

Return _the maximum profit you can achieve from this transaction_. If you cannot achieve any profit, return `0`.

**Example 1:**

**Input:** prices = [7,1,5,3,6,4]
**Output:** 5
**Explanation:** Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.
Note that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.
## Thoughts

[[Dynamic Programming]]::[[Linear DP]]::[[State Machine DP]]


Difference between them:
1. Your transaction times
2. cool down time...

Your **basic states** are `ONE` and `EMPTY`.
for [[121. to 123 and 128 Best Time to Buy and Sell Stock|121]] , your way to `ONE` is `INIT -> ONE`.(You have one chance to buy.)
for 122, your way to `ONE` is `EMPTY(INIT) -> ONE`(Infinite transaction)
for [[123. and 188. Best Time to Buy and Sell Stock III and IV|123. and 188.]] your way to your `ONE` is flatternd into **several states** `ONEa`, `ONEb`, ... `ONEx`.  



## My Template

``` cpp
// ...

int main() {
	// given
	vector<int> nums;
	int n = limit_of_transaction;
	
	// consts
	
	const int dpl = nums.size(); // key point 1. **use 1-based array** 
	const int states = x; // for 121 and 122 is 2, for 188 is 2 * n+1;// 
	
	// dp array
	vector<vector<int>> dp(dpl, vector<int>(states, 0));
	
	// init
	for (int i = 0; i<states; i++) {
		if (i %2 == 1) dp[1][i] = -prices[0];
	}
	
	// i start from day2
	for (int i = 2; i < dpl+1; i++) {
		const int cur = prices[i-1] // key point 2. i-1 to 0-based
		for (int j = 1; j < states+1; j++) {
			if (j % 2 == 0) {
				dp[i][j] = max(dp[i-1][j], dp[i-1][j-1]-cur);
			}
			else {
				dp[i][j] = max(dp[i-1][j], dp[i-1][j-1]+cur);
			}
		}
	}
	printf("/d", dp[dpl][states]);
	return 0;
}
```

### My Template 2
``` cpp
// ...

int main() {
	// given
	vector<int> nums;
	int n = limit_of_transaction;
	
	// consts
	const int states = x; // for 121 and 122 is 2, for 188 is 2 * n+1;// 
	const int dpl = prices.size();
	// dp array
	vector<int> dp(states, 0);
	
	// init
	for (int i = 0; i<states; i++) {
		if (i %2 == 1) dp[i] = -prices[0];
	}
	
	// i start from day2
	for (int i = 2; i < dpl+1; i++) {
		const int cur = prices[i-1] // key point 2. i-1 to 0-based
		// update in reversed order
		for (int j = states; j > 0; j--) {
			if (j % 2 == 0) {
				dp[j] = max(dp[j], dp[j-1]-cur);
			}
			else {
				dp[i][j] = max(dp[j], dp[j-1]+cur);
			}
		}
	}
	printf("/d", dp[states]);
	return 0;
}
```

