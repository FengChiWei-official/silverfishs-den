---
tags:
  - type/permanent
  - status/evergreen
  - attr/principle
  - topic/learning
---
## background
based on the rule [[Most of algorithm is try to traverse without duplication]]. **better** then [[Eratosthenes' Sieve]], means less duplication in sieving.

considering digit $6$, we could find that we tried to sieve for 2 times:
1. when we considering digit **2**, we consider $6$ as $3 \times \mathbf{2}$ 
2. when we considering digit **3**, we consider $6$ as $2 \times \mathbf{3}$ 

to avoid this situation, we should not sieving digits by any prime, but a only **primitive factor** , which is the **Minimal Primitive Factor**.
## preparation
 for any number $n$, we can divide them into $(\kappa \times p_{\text{minimal}}^{\tau}) \times p_{\text{minimal}} = k \times p_{\text{minimal}}$. based on the define we know $\kappa > p_{\text{minimal}}$.

so we can traverse all available $k$ and base on it we traverse $p_{\text{minimal}}$,*(that means all primes that less then $k$)*. And we can awareness that if the $k$ is divisible for a possible $p_{\text{minimal}}$ then all greater ones will be impossible .
> for if $p_0 \mid k$, or we can say $k = q \times p_0$, then any n generated by k and greater $p_i$ can be written as $n = kq_i = q\times p_0 \times p_i$. It is trivial that minimal primitive factor is $p_0$.
> so we should sieve it when $k = q \times p_i$.

## algorithm
```
found_p:: all found primes.
p_mask:: mark each number is prime or not.

for possible_k in n
	if p_mask of possible_k is not False so far, we can imply that it is a prime
		possible_k -> found_p
		
	// use k to generate k \times p
	for possible_p in found_p:
		p_mask[possible_k * possible_p] = False
		if possible_k % possible_p == 0:
			break 
			// for coming p are not possible to be minimal primitive factor.
		
		
```

## edges
**1** cannot be resolved.
minus ones either.



---
## **related**ï¼š